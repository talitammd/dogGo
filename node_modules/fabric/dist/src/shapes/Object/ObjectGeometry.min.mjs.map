{"version":3,"file":"ObjectGeometry.min.mjs","sources":["../../../../src/shapes/Object/ObjectGeometry.ts"],"sourcesContent":["import type {\n  TBBox,\n  TCornerPoint,\n  TDegree,\n  TMat2D,\n  TOriginX,\n  TOriginY,\n} from '../../typedefs';\nimport { SCALE_X, SCALE_Y, iMatrix } from '../../constants';\nimport { Intersection } from '../../Intersection';\nimport { Point } from '../../Point';\nimport { makeBoundingBoxFromPoints } from '../../util/misc/boundingBoxFromPoints';\nimport {\n  createRotateMatrix,\n  createTranslateMatrix,\n  composeMatrix,\n  invertTransform,\n  multiplyTransformMatrices,\n  transformPoint,\n  calcPlaneRotation,\n} from '../../util/misc/matrix';\nimport { radiansToDegrees } from '../../util/misc/radiansDegreesConversion';\nimport type { Canvas } from '../../canvas/Canvas';\nimport type { StaticCanvas } from '../../canvas/StaticCanvas';\nimport { ObjectOrigin } from './ObjectOrigin';\nimport type { ObjectEvents } from '../../EventTypeDefs';\nimport type { ControlProps } from './types/ControlProps';\nimport { resolveOrigin } from '../../util/misc/resolveOrigin';\n\ntype TMatrixCache = {\n  key: number[];\n  value: TMat2D;\n};\n\ntype TACoords = TCornerPoint;\n\nexport class ObjectGeometry<EventSpec extends ObjectEvents = ObjectEvents>\n  extends ObjectOrigin<EventSpec>\n  implements Pick<ControlProps, 'padding'>\n{\n  declare padding: number;\n\n  /**\n   * Describe object's corner position in scene coordinates.\n   * The coordinates are derived from the following:\n   * left, top, width, height, scaleX, scaleY, skewX, skewY, angle, strokeWidth.\n   * The coordinates do not depend on viewport changes.\n   * The coordinates get updated with {@link setCoords}.\n   * You can calculate them without updating with {@link calcACoords()}\n   */\n  declare aCoords: TACoords;\n\n  /**\n   * storage cache for object transform matrix\n   */\n  declare ownMatrixCache?: TMatrixCache;\n\n  /**\n   * storage cache for object full transform matrix\n   */\n  declare matrixCache?: TMatrixCache;\n\n  /**\n   * A Reference of the Canvas where the object is actually added\n   * @type StaticCanvas | Canvas;\n   * @default undefined\n   * @private\n   */\n  declare canvas?: StaticCanvas | Canvas;\n\n  /**\n   * @returns {number} x position according to object's {@link originX} property in canvas coordinate plane\n   */\n  getX(): number {\n    return this.getXY().x;\n  }\n\n  /**\n   * @param {number} value x position according to object's {@link originX} property in canvas coordinate plane\n   */\n  setX(value: number) {\n    this.setXY(this.getXY().setX(value));\n  }\n\n  /**\n   * @returns {number} y position according to object's {@link originY} property in canvas coordinate plane\n   */\n  getY(): number {\n    return this.getXY().y;\n  }\n\n  /**\n   * @param {number} value y position according to object's {@link originY} property in canvas coordinate plane\n   */\n  setY(value: number) {\n    this.setXY(this.getXY().setY(value));\n  }\n\n  /**\n   * @returns {number} x position according to object's {@link originX} property in parent's coordinate plane\\\n   * if parent is canvas then this property is identical to {@link getX}\n   */\n  getRelativeX(): number {\n    return this.left;\n  }\n\n  /**\n   * @param {number} value x position according to object's {@link originX} property in parent's coordinate plane\\\n   * if parent is canvas then this method is identical to {@link setX}\n   */\n  setRelativeX(value: number) {\n    this.left = value;\n  }\n\n  /**\n   * @returns {number} y position according to object's {@link originY} property in parent's coordinate plane\\\n   * if parent is canvas then this property is identical to {@link getY}\n   */\n  getRelativeY(): number {\n    return this.top;\n  }\n\n  /**\n   * @param {number} value y position according to object's {@link originY} property in parent's coordinate plane\\\n   * if parent is canvas then this property is identical to {@link setY}\n   */\n  setRelativeY(value: number) {\n    this.top = value;\n  }\n\n  /**\n   * @returns {Point} x position according to object's {@link originX} {@link originY} properties in canvas coordinate plane\n   */\n  getXY(): Point {\n    const relativePosition = this.getRelativeXY();\n    return this.group\n      ? transformPoint(relativePosition, this.group.calcTransformMatrix())\n      : relativePosition;\n  }\n\n  /**\n   * Set an object position to a particular point, the point is intended in absolute ( canvas ) coordinate.\n   * You can specify {@link originX} and {@link originY} values,\n   * that otherwise are the object's current values.\n   * @example <caption>Set object's bottom left corner to point (5,5) on canvas</caption>\n   * object.setXY(new Point(5, 5), 'left', 'bottom').\n   * @param {Point} point position in scene coordinate plane\n   * @param {TOriginX} [originX] Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} [originY] Vertical origin: 'top', 'center' or 'bottom'\n   */\n  setXY(point: Point, originX?: TOriginX, originY?: TOriginY) {\n    if (this.group) {\n      point = transformPoint(\n        point,\n        invertTransform(this.group.calcTransformMatrix()),\n      );\n    }\n    this.setRelativeXY(point, originX, originY);\n  }\n\n  /**\n   * @returns {Point} x,y position according to object's {@link originX} {@link originY} properties in parent's coordinate plane\n   */\n  getRelativeXY(): Point {\n    return new Point(this.left, this.top);\n  }\n\n  /**\n   * As {@link setXY}, but in current parent's coordinate plane (the current group if any or the canvas)\n   * @param {Point} point position according to object's {@link originX} {@link originY} properties in parent's coordinate plane\n   * @param {TOriginX} [originX] Horizontal origin: 'left', 'center' or 'right'\n   * @param {TOriginY} [originY] Vertical origin: 'top', 'center' or 'bottom'\n   */\n  setRelativeXY(\n    point: Point,\n    originX: TOriginX = this.originX,\n    originY: TOriginY = this.originY,\n  ) {\n    this.setPositionByOrigin(point, originX, originY);\n  }\n\n  /**\n   * @deprecated intermidiate method to be removed, do not use\n   */\n  protected isStrokeAccountedForInDimensions() {\n    return false;\n  }\n\n  /**\n   * @return {Point[]} [tl, tr, br, bl] in the scene plane\n   */\n  getCoords(): Point[] {\n    const { tl, tr, br, bl } =\n      this.aCoords || (this.aCoords = this.calcACoords());\n    const coords = [tl, tr, br, bl];\n    if (this.group) {\n      const t = this.group.calcTransformMatrix();\n      return coords.map((p) => transformPoint(p, t));\n    }\n    return coords;\n  }\n\n  /**\n   * Checks if object intersects with the scene rect formed by {@link tl} and {@link br}\n   */\n  intersectsWithRect(tl: Point, br: Point): boolean {\n    const intersection = Intersection.intersectPolygonRectangle(\n      this.getCoords(),\n      tl,\n      br,\n    );\n    return intersection.status === 'Intersection';\n  }\n\n  /**\n   * Checks if object intersects with another object\n   * @param {Object} other Object to test\n   * @return {Boolean} true if object intersects with another object\n   */\n  intersectsWithObject(other: ObjectGeometry): boolean {\n    const intersection = Intersection.intersectPolygonPolygon(\n      this.getCoords(),\n      other.getCoords(),\n    );\n\n    return (\n      intersection.status === 'Intersection' ||\n      intersection.status === 'Coincident' ||\n      other.isContainedWithinObject(this) ||\n      this.isContainedWithinObject(other)\n    );\n  }\n\n  /**\n   * Checks if object is fully contained within area of another object\n   * @param {Object} other Object to test\n   * @return {Boolean} true if object is fully contained within area of another object\n   */\n  isContainedWithinObject(other: ObjectGeometry): boolean {\n    const points = this.getCoords();\n    return points.every((point) => other.containsPoint(point));\n  }\n\n  /**\n   * Checks if object is fully contained within the scene rect formed by {@link tl} and {@link br}\n   */\n  isContainedWithinRect(tl: Point, br: Point): boolean {\n    const { left, top, width, height } = this.getBoundingRect();\n    return (\n      left >= tl.x &&\n      left + width <= br.x &&\n      top >= tl.y &&\n      top + height <= br.y\n    );\n  }\n\n  isOverlapping<T extends ObjectGeometry>(other: T): boolean {\n    return (\n      this.intersectsWithObject(other) ||\n      this.isContainedWithinObject(other) ||\n      other.isContainedWithinObject(this)\n    );\n  }\n\n  /**\n   * Checks if point is inside the object\n   * @param {Point} point Point to check against\n   * @return {Boolean} true if point is inside the object\n   */\n  containsPoint(point: Point): boolean {\n    return Intersection.isPointInPolygon(point, this.getCoords());\n  }\n\n  /**\n   * Checks if object is contained within the canvas with current viewportTransform\n   * the check is done stopping at first point that appears on screen\n   * @return {Boolean} true if object is fully or partially contained within canvas\n   */\n  isOnScreen(): boolean {\n    if (!this.canvas) {\n      return false;\n    }\n    const { tl, br } = this.canvas.vptCoords;\n    const points = this.getCoords();\n    // if some point is on screen, the object is on screen.\n    if (\n      points.some(\n        (point) =>\n          point.x <= br.x &&\n          point.x >= tl.x &&\n          point.y <= br.y &&\n          point.y >= tl.y,\n      )\n    ) {\n      return true;\n    }\n    // no points on screen, check intersection with absolute coordinates\n    if (this.intersectsWithRect(tl, br)) {\n      return true;\n    }\n    // check if the object is so big that it contains the entire viewport\n    return this.containsPoint(tl.midPointFrom(br));\n  }\n\n  /**\n   * Checks if object is partially contained within the canvas with current viewportTransform\n   * @return {Boolean} true if object is partially contained within canvas\n   */\n  isPartiallyOnScreen(): boolean {\n    if (!this.canvas) {\n      return false;\n    }\n    const { tl, br } = this.canvas.vptCoords;\n    if (this.intersectsWithRect(tl, br)) {\n      return true;\n    }\n    const allPointsAreOutside = this.getCoords().every(\n      (point) =>\n        (point.x >= br.x || point.x <= tl.x) &&\n        (point.y >= br.y || point.y <= tl.y),\n    );\n    // check if the object is so big that it contains the entire viewport\n    return allPointsAreOutside && this.containsPoint(tl.midPointFrom(br));\n  }\n\n  /**\n   * Returns coordinates of object's bounding rectangle (left, top, width, height)\n   * the box is intended as aligned to axis of canvas.\n   * @return {Object} Object with left, top, width, height properties\n   */\n  getBoundingRect(): TBBox {\n    return makeBoundingBoxFromPoints(this.getCoords());\n  }\n\n  /**\n   * Returns width of an object's bounding box counting transformations\n   * @todo shouldn't this account for group transform and return the actual size in canvas coordinate plane?\n   * @return {Number} width value\n   */\n  getScaledWidth(): number {\n    return this._getTransformedDimensions().x;\n  }\n\n  /**\n   * Returns height of an object bounding box counting transformations\n   * @todo shouldn't this account for group transform and return the actual size in canvas coordinate plane?\n   * @return {Number} height value\n   */\n  getScaledHeight(): number {\n    return this._getTransformedDimensions().y;\n  }\n\n  /**\n   * Scales an object (equally by x and y)\n   * @param {Number} value Scale factor\n   * @return {void}\n   */\n  scale(value: number): void {\n    this._set(SCALE_X, value);\n    this._set(SCALE_Y, value);\n    this.setCoords();\n  }\n\n  /**\n   * Scales an object to a given width, with respect to bounding box (scaling by x/y equally)\n   * @param {Number} value New width value\n   * @return {void}\n   */\n  scaleToWidth(value: number) {\n    // adjust to bounding rect factor so that rotated shapes would fit as well\n    const boundingRectFactor =\n      this.getBoundingRect().width / this.getScaledWidth();\n    return this.scale(value / this.width / boundingRectFactor);\n  }\n\n  /**\n   * Scales an object to a given height, with respect to bounding box (scaling by x/y equally)\n   * @param {Number} value New height value\n   * @return {void}\n   */\n  scaleToHeight(value: number) {\n    // adjust to bounding rect factor so that rotated shapes would fit as well\n    const boundingRectFactor =\n      this.getBoundingRect().height / this.getScaledHeight();\n    return this.scale(value / this.height / boundingRectFactor);\n  }\n\n  getCanvasRetinaScaling() {\n    return this.canvas?.getRetinaScaling() || 1;\n  }\n\n  /**\n   * Returns the object angle relative to canvas counting also the group property\n   * @returns {TDegree}\n   */\n  getTotalAngle(): TDegree {\n    return this.group\n      ? radiansToDegrees(calcPlaneRotation(this.calcTransformMatrix()))\n      : this.angle;\n  }\n\n  /**\n   * Retrieves viewportTransform from Object's canvas if available\n   * @return {TMat2D}\n   */\n  getViewportTransform(): TMat2D {\n    return this.canvas?.viewportTransform || (iMatrix.concat() as TMat2D);\n  }\n\n  /**\n   * Calculates the coordinates of the 4 corner of the bbox, in absolute coordinates.\n   * those never change with zoom or viewport changes.\n   * @return {TCornerPoint}\n   */\n  calcACoords(): TCornerPoint {\n    const rotateMatrix = createRotateMatrix({ angle: this.angle }),\n      { x, y } = this.getRelativeCenterPoint(),\n      tMatrix = createTranslateMatrix(x, y),\n      finalMatrix = multiplyTransformMatrices(tMatrix, rotateMatrix),\n      dim = this._getTransformedDimensions(),\n      w = dim.x / 2,\n      h = dim.y / 2;\n    return {\n      // corners\n      tl: transformPoint({ x: -w, y: -h }, finalMatrix),\n      tr: transformPoint({ x: w, y: -h }, finalMatrix),\n      bl: transformPoint({ x: -w, y: h }, finalMatrix),\n      br: transformPoint({ x: w, y: h }, finalMatrix),\n    };\n  }\n\n  /**\n   * Sets corner and controls position coordinates based on current angle, width and height, left and top.\n   * aCoords are used to quickly find an object on the canvas.\n   * See {@link https://github.com/fabricjs/fabric.js/wiki/When-to-call-setCoords} and {@link http://fabricjs.com/fabric-gotchas}\n   */\n  setCoords(): void {\n    this.aCoords = this.calcACoords();\n  }\n\n  transformMatrixKey(skipGroup = false): number[] {\n    let prefix: number[] = [];\n    if (!skipGroup && this.group) {\n      prefix = this.group.transformMatrixKey(skipGroup);\n    }\n    prefix.push(\n      this.top,\n      this.left,\n      this.width,\n      this.height,\n      this.scaleX,\n      this.scaleY,\n      this.angle,\n      this.strokeWidth,\n      this.skewX,\n      this.skewY,\n      +this.flipX,\n      +this.flipY,\n      resolveOrigin(this.originX),\n      resolveOrigin(this.originY),\n    );\n\n    return prefix;\n  }\n\n  /**\n   * calculate transform matrix that represents the current transformations from the\n   * object's properties.\n   * @param {Boolean} [skipGroup] return transform matrix for object not counting parent transformations\n   * There are some situation in which this is useful to avoid the fake rotation.\n   * @return {TMat2D} transform matrix for the object\n   */\n  calcTransformMatrix(skipGroup = false): TMat2D {\n    let matrix = this.calcOwnMatrix();\n    if (skipGroup || !this.group) {\n      return matrix;\n    }\n    const key = this.transformMatrixKey(skipGroup),\n      cache = this.matrixCache;\n    if (cache && cache.key.every((x, i) => x === key[i])) {\n      return cache.value;\n    }\n    if (this.group) {\n      matrix = multiplyTransformMatrices(\n        this.group.calcTransformMatrix(false),\n        matrix,\n      );\n    }\n    this.matrixCache = {\n      key,\n      value: matrix,\n    };\n    return matrix;\n  }\n\n  /**\n   * calculate transform matrix that represents the current transformations from the\n   * object's properties, this matrix does not include the group transformation\n   * @return {TMat2D} transform matrix for the object\n   */\n  calcOwnMatrix(): TMat2D {\n    const key = this.transformMatrixKey(true),\n      cache = this.ownMatrixCache;\n    if (cache && cache.key === key) {\n      return cache.value;\n    }\n    const center = this.getRelativeCenterPoint(),\n      options = {\n        angle: this.angle,\n        translateX: center.x,\n        translateY: center.y,\n        scaleX: this.scaleX,\n        scaleY: this.scaleY,\n        skewX: this.skewX,\n        skewY: this.skewY,\n        flipX: this.flipX,\n        flipY: this.flipY,\n      },\n      value = composeMatrix(options);\n    this.ownMatrixCache = {\n      key,\n      value,\n    };\n    return value;\n  }\n\n  /**\n   * Calculate object dimensions from its properties\n   * @private\n   * @returns {Point} dimensions\n   */\n  _getNonTransformedDimensions(): Point {\n    return new Point(this.width, this.height).scalarAdd(this.strokeWidth);\n  }\n\n  /**\n   * Calculate object dimensions for controls box, including padding and canvas zoom.\n   * and active selection\n   * @private\n   * @param {object} [options] transform options\n   * @returns {Point} dimensions\n   */\n  _calculateCurrentDimensions(options?: any): Point {\n    return this._getTransformedDimensions(options)\n      .transform(this.getViewportTransform(), true)\n      .scalarAdd(2 * this.padding);\n  }\n}\n"],"names":["ObjectGeometry","ObjectOrigin","getX","this","getXY","x","setX","value","setXY","getY","y","setY","getRelativeX","left","setRelativeX","getRelativeY","top","setRelativeY","relativePosition","getRelativeXY","group","transformPoint","calcTransformMatrix","point","originX","originY","invertTransform","setRelativeXY","Point","arguments","length","undefined","setPositionByOrigin","isStrokeAccountedForInDimensions","getCoords","tl","tr","br","bl","aCoords","calcACoords","coords","t","map","p","intersectsWithRect","Intersection","intersectPolygonRectangle","status","intersectsWithObject","other","intersection","intersectPolygonPolygon","isContainedWithinObject","every","containsPoint","isContainedWithinRect","width","height","getBoundingRect","isOverlapping","isPointInPolygon","isOnScreen","canvas","vptCoords","some","midPointFrom","isPartiallyOnScreen","makeBoundingBoxFromPoints","getScaledWidth","_getTransformedDimensions","getScaledHeight","scale","_set","SCALE_X","SCALE_Y","setCoords","scaleToWidth","boundingRectFactor","scaleToHeight","getCanvasRetinaScaling","_this$canvas","getRetinaScaling","getTotalAngle","radiansToDegrees","calcPlaneRotation","angle","getViewportTransform","_this$canvas2","viewportTransform","iMatrix","concat","rotateMatrix","createRotateMatrix","getRelativeCenterPoint","tMatrix","createTranslateMatrix","finalMatrix","multiplyTransformMatrices","dim","w","h","transformMatrixKey","skipGroup","prefix","push","scaleX","scaleY","strokeWidth","skewX","skewY","flipX","flipY","resolveOrigin","matrix","calcOwnMatrix","key","cache","matrixCache","i","ownMatrixCache","center","options","translateX","translateY","composeMatrix","_getNonTransformedDimensions","scalarAdd","_calculateCurrentDimensions","transform","padding"],"mappings":"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"}