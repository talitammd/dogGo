import{SCALE_X as t,SCALE_Y as i,iMatrix as s}from"../../constants.min.mjs";import{Intersection as e}from"../../Intersection.min.mjs";import{Point as r}from"../../Point.min.mjs";import{makeBoundingBoxFromPoints as n}from"../../util/misc/boundingBoxFromPoints.min.mjs";import{transformPoint as o,invertTransform as h,calcPlaneRotation as a,createRotateMatrix as c,multiplyTransformMatrices as l,composeMatrix as g,createTranslateMatrix as m}from"../../util/misc/matrix.min.mjs";import{radiansToDegrees as u}from"../../util/misc/radiansDegreesConversion.min.mjs";import{ObjectOrigin as d}from"./ObjectOrigin.min.mjs";import{resolveOrigin as f}from"../../util/misc/resolveOrigin.min.mjs";class p extends d{getX(){return this.getXY().x}setX(t){this.setXY(this.getXY().setX(t))}getY(){return this.getXY().y}setY(t){this.setXY(this.getXY().setY(t))}getRelativeX(){return this.left}setRelativeX(t){this.left=t}getRelativeY(){return this.top}setRelativeY(t){this.top=t}getXY(){const t=this.getRelativeXY();return this.group?o(t,this.group.calcTransformMatrix()):t}setXY(t,i,s){this.group&&(t=o(t,h(this.group.calcTransformMatrix()))),this.setRelativeXY(t,i,s)}getRelativeXY(){return new r(this.left,this.top)}setRelativeXY(t){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.originX,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.originY;this.setPositionByOrigin(t,i,s)}isStrokeAccountedForInDimensions(){return!1}getCoords(){const{tl:t,tr:i,br:s,bl:e}=this.aCoords||(this.aCoords=this.calcACoords()),r=[t,i,s,e];if(this.group){const t=this.group.calcTransformMatrix();return r.map((i=>o(i,t)))}return r}intersectsWithRect(t,i){return"Intersection"===e.intersectPolygonRectangle(this.getCoords(),t,i).status}intersectsWithObject(t){const i=e.intersectPolygonPolygon(this.getCoords(),t.getCoords());return"Intersection"===i.status||"Coincident"===i.status||t.isContainedWithinObject(this)||this.isContainedWithinObject(t)}isContainedWithinObject(t){return this.getCoords().every((i=>t.containsPoint(i)))}isContainedWithinRect(t,i){const{left:s,top:e,width:r,height:n}=this.getBoundingRect();return s>=t.x&&s+r<=i.x&&e>=t.y&&e+n<=i.y}isOverlapping(t){return this.intersectsWithObject(t)||this.isContainedWithinObject(t)||t.isContainedWithinObject(this)}containsPoint(t){return e.isPointInPolygon(t,this.getCoords())}isOnScreen(){if(!this.canvas)return!1;const{tl:t,br:i}=this.canvas.vptCoords;return!!this.getCoords().some((s=>s.x<=i.x&&s.x>=t.x&&s.y<=i.y&&s.y>=t.y))||(!!this.intersectsWithRect(t,i)||this.containsPoint(t.midPointFrom(i)))}isPartiallyOnScreen(){if(!this.canvas)return!1;const{tl:t,br:i}=this.canvas.vptCoords;if(this.intersectsWithRect(t,i))return!0;return this.getCoords().every((s=>(s.x>=i.x||s.x<=t.x)&&(s.y>=i.y||s.y<=t.y)))&&this.containsPoint(t.midPointFrom(i))}getBoundingRect(){return n(this.getCoords())}getScaledWidth(){return this._getTransformedDimensions().x}getScaledHeight(){return this._getTransformedDimensions().y}scale(s){this._set(t,s),this._set(i,s),this.setCoords()}scaleToWidth(t){const i=this.getBoundingRect().width/this.getScaledWidth();return this.scale(t/this.width/i)}scaleToHeight(t){const i=this.getBoundingRect().height/this.getScaledHeight();return this.scale(t/this.height/i)}getCanvasRetinaScaling(){var t;return(null===(t=this.canvas)||void 0===t?void 0:t.getRetinaScaling())||1}getTotalAngle(){return this.group?u(a(this.calcTransformMatrix())):this.angle}getViewportTransform(){var t;return(null===(t=this.canvas)||void 0===t?void 0:t.viewportTransform)||s.concat()}calcACoords(){const t=c({angle:this.angle}),{x:i,y:s}=this.getRelativeCenterPoint(),e=m(i,s),r=l(e,t),n=this._getTransformedDimensions(),h=n.x/2,a=n.y/2;return{tl:o({x:-h,y:-a},r),tr:o({x:h,y:-a},r),bl:o({x:-h,y:a},r),br:o({x:h,y:a},r)}}setCoords(){this.aCoords=this.calcACoords()}transformMatrixKey(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=[];return!t&&this.group&&(i=this.group.transformMatrixKey(t)),i.push(this.top,this.left,this.width,this.height,this.scaleX,this.scaleY,this.angle,this.strokeWidth,this.skewX,this.skewY,+this.flipX,+this.flipY,f(this.originX),f(this.originY)),i}calcTransformMatrix(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0],i=this.calcOwnMatrix();if(t||!this.group)return i;const s=this.transformMatrixKey(t),e=this.matrixCache;return e&&e.key.every(((t,i)=>t===s[i]))?e.value:(this.group&&(i=l(this.group.calcTransformMatrix(!1),i)),this.matrixCache={key:s,value:i},i)}calcOwnMatrix(){const t=this.transformMatrixKey(!0),i=this.ownMatrixCache;if(i&&i.key===t)return i.value;const s=this.getRelativeCenterPoint(),e={angle:this.angle,translateX:s.x,translateY:s.y,scaleX:this.scaleX,scaleY:this.scaleY,skewX:this.skewX,skewY:this.skewY,flipX:this.flipX,flipY:this.flipY},r=g(e);return this.ownMatrixCache={key:t,value:r},r}_getNonTransformedDimensions(){return new r(this.width,this.height).scalarAdd(this.strokeWidth)}_calculateCurrentDimensions(t){return this._getTransformedDimensions(t).transform(this.getViewportTransform(),!0).scalarAdd(2*this.padding)}}export{p as ObjectGeometry};
//# sourceMappingURL=ObjectGeometry.min.mjs.map
