import{objectSpread2 as t}from"../../../_virtual/_rollupPluginBabelHelpers.min.mjs";import{cache as e}from"../../cache.min.mjs";import{config as n}from"../../config.min.mjs";import{halfPI as s,PiBy180 as r}from"../../constants.min.mjs";import{cos as a}from"../misc/cos.min.mjs";import{multiplyTransformMatrices as o,transformPoint as c}from"../misc/matrix.min.mjs";import{sin as i}from"../misc/sin.min.mjs";import{toFixed as l}from"../misc/toFixed.min.mjs";import{Point as h}from"../../Point.min.mjs";import{rePathCommand as m}from"./regex.min.mjs";import{cleanupSvgAttribute as u}from"../internals/cleanupSvgAttribute.min.mjs";const f={m:"l",M:"L"},x=(t,e,n,s,r,o,c,l,h,m,u)=>{const f=a(t),x=i(t),p=a(e),g=i(e),y=n*r*p-s*o*g+c,M=s*r*p+n*o*g+l;return["C",m+h*(-n*r*x-s*o*f),u+h*(-s*r*x+n*o*f),y+h*(n*r*g+s*o*p),M+h*(s*r*g-n*o*p),y,M]},p=(t,e,n,s)=>{const r=Math.atan2(e,t),a=Math.atan2(s,n);return a>=r?a-r:2*Math.PI-(r-a)};function g(t,s,r,a,o,c,i,l){let m;if(n.cachesBoundsOfCurve&&(m=[...arguments].join(),e.boundsOfCurveCache[m]))return e.boundsOfCurveCache[m];const u=Math.sqrt,f=Math.abs,x=[],p=[[0,0],[0,0]];let g=6*t-12*r+6*o,y=-3*t+9*r-9*o+3*i,M=3*r-3*t;for(let t=0;t<2;++t){if(t>0&&(g=6*s-12*a+6*c,y=-3*s+9*a-9*c+3*l,M=3*a-3*s),f(y)<1e-12){if(f(g)<1e-12)continue;const t=-M/g;0<t&&t<1&&x.push(t);continue}const e=g*g-4*M*y;if(e<0)continue;const n=u(e),r=(-g+n)/(2*y);0<r&&r<1&&x.push(r);const o=(-g-n)/(2*y);0<o&&o<1&&x.push(o)}let b=x.length;const w=b,j=d(t,s,r,a,o,c,i,l);for(;b--;){const{x:t,y:e}=j(x[b]);p[0][b]=t,p[1][b]=e}p[0][w]=t,p[1][w]=s,p[0][w+1]=i,p[1][w+1]=l;const k=[new h(Math.min(...p[0]),Math.min(...p[1])),new h(Math.max(...p[0]),Math.max(...p[1]))];return n.cachesBoundsOfCurve&&(e.boundsOfCurveCache[m]=k),k}const y=(t,e,n)=>{let[s,o,c,l,h,m,u,f]=n;const g=((t,e,n,s,o,c,l)=>{if(0===n||0===s)return[];let h=0,m=0,u=0;const f=Math.PI,g=l*r,y=i(g),M=a(g),b=.5*(-M*t-y*e),d=.5*(-M*e+y*t),w=n**2,j=s**2,k=d**2,C=b**2,v=w*j-w*k-j*C;let L=Math.abs(n),Q=Math.abs(s);if(v<0){const t=Math.sqrt(1-v/(w*j));L*=t,Q*=t}else u=(o===c?-1:1)*Math.sqrt(v/(w*k+j*C));const q=u*L*d/Q,F=-u*Q*b/L,P=M*q-y*F+.5*t,E=y*q+M*F+.5*e;let O=p(1,0,(b-q)/L,(d-F)/Q),Z=p((b-q)/L,(d-F)/Q,(-b-q)/L,(-d-F)/Q);0===c&&Z>0?Z-=2*f:1===c&&Z<0&&(Z+=2*f);const A=Math.ceil(Math.abs(Z/f*2)),N=[],B=Z/A,I=8/3*Math.sin(B/4)*Math.sin(B/4)/Math.sin(B/2);let R=O+B;for(let t=0;t<A;t++)N[t]=x(O,R,M,y,L,Q,P,E,I,h,m),h=N[t][5],m=N[t][6],O=R,R+=B;return N})(u-t,f-e,o,c,h,m,l);for(let n=0,s=g.length;n<s;n++)g[n][1]+=t,g[n][2]+=e,g[n][3]+=t,g[n][4]+=e,g[n][5]+=t,g[n][6]+=e;return g},M=t=>{let e=0,n=0,s=0,r=0;const a=[];let o,c=0,i=0;for(const l of t){const t=[...l];let h;switch(t[0]){case"l":t[1]+=e,t[2]+=n;case"L":e=t[1],n=t[2],h=["L",e,n];break;case"h":t[1]+=e;case"H":e=t[1],h=["L",e,n];break;case"v":t[1]+=n;case"V":n=t[1],h=["L",e,n];break;case"m":t[1]+=e,t[2]+=n;case"M":e=t[1],n=t[2],s=t[1],r=t[2],h=["M",e,n];break;case"c":t[1]+=e,t[2]+=n,t[3]+=e,t[4]+=n,t[5]+=e,t[6]+=n;case"C":c=t[3],i=t[4],e=t[5],n=t[6],h=["C",t[1],t[2],c,i,e,n];break;case"s":t[1]+=e,t[2]+=n,t[3]+=e,t[4]+=n;case"S":"C"===o?(c=2*e-c,i=2*n-i):(c=e,i=n),e=t[3],n=t[4],h=["C",c,i,t[1],t[2],e,n],c=h[3],i=h[4];break;case"q":t[1]+=e,t[2]+=n,t[3]+=e,t[4]+=n;case"Q":c=t[1],i=t[2],e=t[3],n=t[4],h=["Q",c,i,e,n];break;case"t":t[1]+=e,t[2]+=n;case"T":"Q"===o?(c=2*e-c,i=2*n-i):(c=e,i=n),e=t[1],n=t[2],h=["Q",c,i,e,n];break;case"a":t[6]+=e,t[7]+=n;case"A":y(e,n,t).forEach((t=>a.push(t))),e=t[6],n=t[7];break;case"z":case"Z":e=s,n=r,h=["Z"]}h?(a.push(h),o=h[0]):o=""}return a},b=(t,e,n,s)=>Math.sqrt((n-t)**2+(s-e)**2),d=(t,e,n,s,r,a,o,c)=>i=>{const l=i**3,m=(t=>3*t**2*(1-t))(i),u=(t=>3*t*(1-t)**2)(i),f=(t=>(1-t)**3)(i);return new h(o*l+r*m+n*u+t*f,c*l+a*m+s*u+e*f)},w=t=>t**2,j=t=>2*t*(1-t),k=t=>(1-t)**2,C=(t,e,n,s,r,a,o,c)=>i=>{const l=w(i),h=j(i),m=k(i),u=3*(m*(n-t)+h*(r-n)+l*(o-r)),f=3*(m*(s-e)+h*(a-s)+l*(c-a));return Math.atan2(f,u)},v=(t,e,n,s,r,a)=>o=>{const c=w(o),i=j(o),l=k(o);return new h(r*c+n*i+t*l,a*c+s*i+e*l)},L=(t,e,n,s,r,a)=>o=>{const c=1-o,i=2*(c*(n-t)+o*(r-n)),l=2*(c*(s-e)+o*(a-s));return Math.atan2(l,i)},Q=(t,e,n)=>{let s=new h(e,n),r=0;for(let e=1;e<=100;e+=1){const n=t(e/100);r+=b(s.x,s.y,n.x,n.y),s=n}return r},q=(e,n)=>{let s,r=0,a=0,o={x:e.x,y:e.y},c=t({},o),i=.01,l=0;const h=e.iterator,m=e.angleFinder;for(;a<n&&i>1e-4;)c=h(r),l=r,s=b(o.x,o.y,c.x,c.y),s+a>n?(r-=i,i/=2):(o=c,r+=i,a+=s);return t(t({},c),{},{angle:m(l)})},F=t=>{let e,n,s=0,r=0,a=0,o=0,c=0;const i=[];for(const l of t){const t={x:r,y:a,command:l[0],length:0};switch(l[0]){case"M":n=t,n.x=o=r=l[1],n.y=c=a=l[2];break;case"L":n=t,n.length=b(r,a,l[1],l[2]),r=l[1],a=l[2];break;case"C":e=d(r,a,l[1],l[2],l[3],l[4],l[5],l[6]),n=t,n.iterator=e,n.angleFinder=C(r,a,l[1],l[2],l[3],l[4],l[5],l[6]),n.length=Q(e,r,a),r=l[5],a=l[6];break;case"Q":e=v(r,a,l[1],l[2],l[3],l[4]),n=t,n.iterator=e,n.angleFinder=L(r,a,l[1],l[2],l[3],l[4]),n.length=Q(e,r,a),r=l[3],a=l[4];break;case"Z":n=t,n.destX=o,n.destY=c,n.length=b(r,a,o,c),r=o,a=c}s+=n.length,i.push(n)}return i.push({length:s,x:r,y:a}),i},P=function(e,n){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:F(e),r=0;for(;n-s[r].length>0&&r<s.length-2;)n-=s[r].length,r++;const a=s[r],o=n/a.length,c=e[r];switch(a.command){case"M":return{x:a.x,y:a.y,angle:0};case"Z":return t(t({},new h(a.x,a.y).lerp(new h(a.destX,a.destY),o)),{},{angle:Math.atan2(a.destY-a.y,a.destX-a.x)});case"L":return t(t({},new h(a.x,a.y).lerp(new h(c[1],c[2]),o)),{},{angle:Math.atan2(c[2]-a.y,c[1]-a.x)});case"C":case"Q":return q(a,n)}},E=new RegExp(m,"gi"),O=new RegExp(m,"i"),Z=t=>{t=u(t);const e=[];for(let[n]of t.matchAll(E)){const t=[];let s;do{if(s=O.exec(n),!s)break;const e=s.filter((t=>t));e.shift();const r=e.map((t=>{const e=Number.parseFloat(t);return Number.isNaN(e)?t:e}));if(t.push(r),e.length<=1)break;e.shift(),n=n.replace(new RegExp("".concat(e.join(" ?")," ?$")),"")}while(s);t.reverse().forEach(((t,n)=>{const s=f[t[0]];n>0&&("l"==s||"L"==s)&&(t[0]=s),e.push(t)}))}return e},A=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=new h(t[0]),s=new h(t[1]),r=1,a=0;const o=[],c=t.length,i=c>2;let l;for(i&&(r=t[2].x<s.x?-1:t[2].x===s.x?0:1,a=t[2].y<s.y?-1:t[2].y===s.y?0:1),o.push(["M",n.x-r*e,n.y-a*e]),l=1;l<c;l++){if(!n.eq(s)){const t=n.midPointFrom(s);o.push(["Q",n.x,n.y,t.x,t.y])}n=t[l],l+1<t.length&&(s=t[l+1])}return i&&(r=n.x>t[l-2].x?1:n.x===t[l-2].x?0:-1,a=n.y>t[l-2].y?1:n.y===t[l-2].y?0:-1),o.push(["L",n.x+r*e,n.y+a*e]),o},N=(t,e,n)=>(n&&(e=o(e,[1,0,0,1,-n.x,-n.y])),t.map((t=>{const n=[...t];for(let s=1;s<t.length-1;s+=2){const{x:r,y:a}=c({x:t[s],y:t[s+1]},e);n[s]=r,n[s+1]=a}return n}))),B=(t,e)=>{const n=2*Math.PI/t;let r=-s;t%2==0&&(r+=n/2);const o=new Array(t+1);for(let s=0;s<t;s++){const t=s*n+r,{x:c,y:l}=new h(a(t),i(t)).scalarMultiply(e);o[s]=[0===s?"M":"L",c,l]}return o[t]=["Z"],o},I=(t,e)=>t.map((t=>t.map(((t,n)=>0===n||void 0===e?t:l(t,e))).join(" "))).join(" ");export{y as fromArcToBeziers,g as getBoundsOfCurve,F as getPathSegmentsInfo,P as getPointOnPath,B as getRegularPolygonPath,A as getSmoothPathFromPoints,I as joinPath,M as makePathSimpler,Z as parsePath,N as transformPath};
//# sourceMappingURL=index.min.mjs.map
